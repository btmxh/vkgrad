#version 450

#define TILE_SIZE 16

layout(local_size_x = TILE_SIZE, local_size_y = TILE_SIZE, local_size_z = 1) in;

layout(std430, binding = 0) readonly buffer ABuffer {
    float A[];
};

layout(std430, binding = 1) readonly buffer BBuffer {
    float B[];
};

layout(std430, binding = 2) writeonly buffer CBuffer {
    float C[];
};

layout(push_constant) uniform PushConsts {
    int M; // rows of A and C
    int N; // cols of B and C
    int K; // cols of A, rows of B
} push;

shared float Asub[TILE_SIZE][TILE_SIZE];
shared float Bsub[TILE_SIZE][TILE_SIZE];

void main() {
    uint row = gl_GlobalInvocationID.y;
    uint col = gl_GlobalInvocationID.x;

    float sum = 0.0;

    for (uint tile = 0; tile < uint((push.K + TILE_SIZE - 1) / TILE_SIZE); ++tile) {
        // Load A tile
        uint tiledRow = row;
        uint tiledCol = tile * TILE_SIZE + gl_LocalInvocationID.x;
        if (tiledRow < uint(push.M) && tiledCol < uint(push.K)) {
            Asub[gl_LocalInvocationID.y][gl_LocalInvocationID.x] = A[tiledRow * push.K + tiledCol];
        } else {
            Asub[gl_LocalInvocationID.y][gl_LocalInvocationID.x] = 0.0;
        }

        // Load B tile
        tiledRow = tile * TILE_SIZE + gl_LocalInvocationID.y;
        tiledCol = col;
        if (tiledRow < uint(push.K) && tiledCol < uint(push.N)) {
            Bsub[gl_LocalInvocationID.y][gl_LocalInvocationID.x] = B[tiledRow * push.N + tiledCol];
        } else {
            Bsub[gl_LocalInvocationID.y][gl_LocalInvocationID.x] = 0.0;
        }

        barrier();

        for (uint k = 0; k < TILE_SIZE; ++k) {
            sum += Asub[gl_LocalInvocationID.y][k] * Bsub[k][gl_LocalInvocationID.x];
        }

        barrier();
    }

    if (row < uint(push.M) && col < uint(push.N)) {
        C[row * push.N + col] = sum;
    }
}
