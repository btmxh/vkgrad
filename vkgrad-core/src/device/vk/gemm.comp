#version 450
#extension GL_KHR_vulkan_memory_model: enable
#extension GL_EXT_control_flow_attributes : enable
#extension GL_EXT_integer_dot_product: enable

#ifndef TILE_SIZE
#define TILE_SIZE 16
#endif

layout(local_size_x = TILE_SIZE * TILE_SIZE) in;

layout(std430, binding = 0) readonly buffer ABuffer {
    float A[];
};

layout(std430, binding = 1) readonly buffer BBuffer {
    float B[];
};

layout(std430, binding = 2) buffer CBuffer {
    float C[];
};

layout(push_constant) uniform PushConsts {
    int M; // rows of A and C
    int N; // cols of B and C
    int K; // cols of A, rows of B
    ivec2 stride_A;
    ivec2 stride_B;
    ivec2 stride_C;
};

shared float shared_A[TILE_SIZE * TILE_SIZE];
shared float shared_B[TILE_SIZE * TILE_SIZE];

#define matrix_get(matrix, pos, stride, size) \
    ((pos.x) < (size).x && (pos.y) < (size).y ? matrix[dotEXT((pos), (stride))] : 0.0)
#define A_get(pos) matrix_get(A, pos, stride_A, ivec2(M, K))
#define B_get(pos) matrix_get(B, pos, stride_B, ivec2(K, N))
#define C_get(pos) matrix_get(C, pos, stride_C, ivec2(M, N))
#define C_set(pos, value) if((pos.x) < M && (pos.y) < N) C[dotEXT((pos), stride_C)] = (value)

// x is row, y is col
void main() {
    const uint local_row = gl_LocalInvocationID.x / TILE_SIZE;
    const uint local_col = gl_LocalInvocationID.x % TILE_SIZE;
    const uvec2 local_pos = uvec2(local_row, local_col);

    const uvec2 block_pos_C = gl_WorkGroupID.xy * TILE_SIZE;
    const uvec2 thread_pos_C = block_pos_C + local_pos;

    float dot_product_total = 0.0;
    int k = 0;
    for (int k = 0; k < K; k += TILE_SIZE) {
        // Load tiles of A and B into shared_A and shared_B
        const uvec2 block_pos_A = uvec2(block_pos_C.x, k);
        const uvec2 block_pos_B = uvec2(k, block_pos_C.y);
        const uvec2 thread_pos_A = block_pos_A + local_pos;
        const uvec2 thread_pos_B = block_pos_B + local_pos;

        const uint thread_pos_shared = local_row * TILE_SIZE + local_col;
        shared_A[thread_pos_shared] = A_get(ivec2(thread_pos_A));
        shared_B[thread_pos_shared] = B_get(ivec2(thread_pos_B));

        barrier();

        // Compute partial dot product for this tile
        for (int j = 0; j < TILE_SIZE; ++j) {
            float a = shared_A[local_row * TILE_SIZE + j];
            float b = shared_B[j * TILE_SIZE + local_col];
            dot_product_total += a * b;
        }

        barrier();
    }

    C_set(thread_pos_C, dot_product_total);
}
